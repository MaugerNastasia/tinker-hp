TODO LIST FOR PIMD IMPLEMENTATION

1) BASIC IMPLEMENTATION

X redefine COMM_TINKER (like COMM_BEAD in CPU implementation)
X rename new modules to MOD_*.f
X port baoabpi to GPU 
    X derivs only on GPU (check when it is created on GPU -> mdinit)
    X check where are the energies (transfer to pi variables)
    - barostat ?
X check if mdstatpi has access to everything on CPU
X prtdynbeads / mdsavebeads (very few modifications needed)
X makefile & dependencies
X use atomsMirror ??? (reCast_position in integrator)
- C_init_env => nproc/nproctot ?

2) OPTIMIZATION

- can we put everything on GPU (less transfer in pushbead/initbead) ?
- can the tasks of ranktot 0 be parallelized on GPU ? (probably yes !)

3) MORE FEATURES

- implement IR SPECTRA (need some QTB routines => port QTB ?)

4) MODULARIZATION

- at the most basic level, separate the variables linked to the potential in 3 categories:
    - global parameters that never change
    - parameters that change and are recomputed at each step
    - parameters that change and must be stored for the next step

- implement objects/structs that encapsulate the parameters by functionality
    - an object for mpoles, neigh, ...
    - a big object that includes x,y,z,vel,a and all the potential parameters ?
        -> like the bead for PIMD

- routines should take arguments that they modify instead of global variables
    => copies not necessary anymore in PIMD (we just pass the bead object)
    - is it still possible to optimize the GPU implementation ?
